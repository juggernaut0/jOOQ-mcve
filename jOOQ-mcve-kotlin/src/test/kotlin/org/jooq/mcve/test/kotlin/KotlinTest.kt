package org.jooq.mcve.test.kotlin

import io.r2dbc.h2.CloseableConnectionFactory
import io.r2dbc.spi.ConnectionFactories
import io.r2dbc.spi.ConnectionFactory
import io.r2dbc.spi.ConnectionFactoryOptions
import org.jooq.DSLContext
import org.jooq.impl.DSL
import org.jooq.mcve.kotlin.tables.references.TEST
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import reactor.core.publisher.Mono

class KotlinTest {
    var connectionFactory: ConnectionFactory? = null
    var ctx: DSLContext? = null

    @Before
    fun setup() {
        connectionFactory = ConnectionFactoryOptions.parse("r2dbc:h2:file:///~/jooq-mcve-kotlin-2")
            .mutate()
            .option(ConnectionFactoryOptions.USER,"sa")
            .option(ConnectionFactoryOptions.PASSWORD, "")
            .build()
            .let { ConnectionFactories.get(it) }
        ctx = DSL.using(connectionFactory)
        Mono.from(ctx().delete(TEST)).block()
    }

    @After
    fun after() {
        ctx = null
        (connectionFactory as? CloseableConnectionFactory)?.close()
        connectionFactory = null
    }

    fun ctx(): DSLContext = ctx!!

    @Test
    fun mcveTest() {
        // Run a transaction that inserts a record then `select count(*)`
        val countFromInsideTx = ctx().transactionPublisher {
            val innerCtx = it.dsl()
            Mono.from(innerCtx.insertInto(TEST).set(TEST.CD, 1)).flatMap {
                Mono.from(innerCtx.selectCount().from(TEST))
            }
        }.let { Mono.from(it) }.block()!!

        // from the select count(*) inside the tx, we expect to see a row
        assertEquals(1, countFromInsideTx.value1())

        // run another select count(*)
        val countAfterTx = Mono.from(ctx().dsl().selectCount().from(TEST)).block()!!

        // from the second count, we expect to still see the row because the tx block should have completed normally
        assertEquals(1, countAfterTx.value1())
    }
}